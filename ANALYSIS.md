# Анализ методов параметрического описания и генерации воксельных кубиков

## Введение

Данный документ содержит детальный анализ различных подходов к параметрическому описанию и генерации воксельных кубиков для веб-редактора isocubic. Основная задача — выбрать оптимальный метод, который обеспечит:

- **Идеальную сшивку границ** между соседними кубиками
- **Высокую производительность** в браузере (60 FPS на мобильных устройствах)
- **Компактное хранение данных** (минимальный размер JSON-конфигов)
- **Гибкость генерации** (поддержка ИИ-генерации по промпту)
- **Физическую интерпретацию** (энергия, плотность материи, разрушение)

---

## 1. 3D Частотный RGBA Спектр (FFT-подход)

### 1.1 Описание метода

Каждый кубик представляется как 3D-массив спектральных коэффициентов в частотной области. Используется дискретное преобразование Фурье (FFT) для перехода между пространственным и спектральным представлением.

#### Математическая основа

Для функции $f(x,y,z)$ размером $N \times N \times N$:

```math
F(u,v,w) = \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} \sum_{z=0}^{N-1} f(x,y,z) \cdot e^{-2\pi i (ux/N + vy/N + wz/N)}
```

**Ключевое свойство:** FFT предполагает периодичность сигнала, что гарантирует 100% сшивку границ:
- $f(0,y,z) = f(N,y,z)$
- $f(x,0,z) = f(x,N,z)$
- $f(x,y,0) = f(x,y,N)$

#### Энергетический формализм

Вместо прямой работы с RGBA-значениями, используется **комплексный потенциал** $\psi$:

```math
\psi_c(x,y,z) = A_c(x,y,z) \cdot e^{i\phi_c(x,y,z)}
```

где $c \in \{r, g, b, a\}$

**Плотность энергии:**
```math
E_c(x,y,z) = |\psi_c(x,y,z)|^2 = A_c^2(x,y,z)
```

**Преимущества энергетического подхода:**
- При $\psi = 0$ везде → $E = 0$ → полный вакуум (нет проблем с DC-компонентом)
- Закон сохранения энергии при преобразованиях (теорема Парсеваля)
- Физически осмысленная интерпретация для игровых механик

### 1.2 Структура данных

```json
{
  "id": "energy_cube_001",
  "fft_size": 8,
  "energy_capacity": 185.3,
  "is_magical": false,
  "channels": {
    "r": {
      "dc_amplitude": 0.75,
      "dc_phase": 0.0,
      "coefficients": [
        {"freq": [1,0,0], "amp": 0.65, "phase": 1.8},
        {"freq": [0,2,0], "amp": 0.45, "phase": 4.2}
      ]
    },
    "g": { ... },
    "b": { ... },
    "a": {
      "dc_amplitude": 0.9,
      "dc_phase": 0.3,
      "coefficients": [
        {"freq": [3,0,0], "amp": 0.8, "phase": 2.7}
      ]
    }
  },
  "physics": {
    "coherence_loss": 0.03,
    "fracture_threshold": 120.0
  }
}
```

### 1.3 Реализация шейдера

```glsl
// energy_cube_fft.glsl
#define PI 3.14159265359
#define EPSILON 0.00001

uniform sampler3D fftCoefficients;
uniform int fftSize;

float energy_density(vec3 pos, int channel) {
  vec2 psi = reconstruct_psi(pos, channel);
  return dot(psi, psi); // |ψ|² = Re² + Im²
}

void main() {
  vec3 pos = vPosition;

  float Er = energy_density(pos, 0);
  float Eg = energy_density(pos, 1);
  float Eb = energy_density(pos, 2);
  float Ea = energy_density(pos, 3);

  float E_total = Er + Eg + Eb + Ea;

  vec3 color = vec3(0.0);
  if (E_total > 0.001) {
    color = vec3(Er, Eg, Eb) / E_total;
  }

  float alpha = Ea / max(E_total, 0.001);
  gl_FragColor = vec4(color * alpha, alpha);
}
```

### 1.4 Преимущества

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Сшивка границ** | ⭐⭐⭐⭐⭐ | Идеальная (100%) благодаря периодичности FFT |
| **Физическая основа** | ⭐⭐⭐⭐⭐ | Полноценная энергетическая модель с законами сохранения |
| **Сжатие данных** | ⭐⭐⭐⭐ | Храним только значимые коэффициенты (3-5KB на куб) |
| **Динамические эффекты** | ⭐⭐⭐⭐⭐ | Естественная модификация через изменение коэффициентов |
| **ИИ-генерация** | ⭐⭐⭐⭐ | Хорошо подходит для генерации по промпту |

### 1.5 Недостатки

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Вычислительная сложность** | ⭐⭐ | O(N³ log N), требует WASM для производительности |
| **Производительность на мобильных** | ⭐⭐⭐ | Без оптимизаций: 20-30 FPS |
| **Сложность реализации** | ⭐⭐ | Требует понимания FFT и комплексных чисел |
| **Контроль локальных деталей** | ⭐⭐⭐ | Сложнее добавлять точечные изменения |
| **Хранение комплексных чисел** | ⭐⭐⭐ | 2 float на коэффициент (Re, Im) |

### 1.6 Оптимизации

1. **WASM-модуль на Rust** для FFT (10-15x быстрее JS)
2. **Усечённый FFT** — храним только K самых значимых коэффициентов
3. **LOD-система** — для дальних кубов используем только DC-компоненты
4. **WebGPU compute-шейдеры** — параллельная генерация текстур плотности

---

## 2. Кубические Фрактальные Деревья

### 2.1 Описание метода

Каждый кубик описывается как **рекурсивная структура** с самоподобием на разных масштабах. Фрактальное дерево определяет, как куб разбивается на подкубы, и какие свойства наследуются на каждом уровне.

#### Математическая основа

Фрактальное дерево — это граф $T = (V, E)$ где:
- $V$ — множество узлов (кубов разного масштаба)
- $E$ — рёбра (отношения родитель-потомок)

**Рекурсивная формула для свойств:**
```math
P_{child}(x,y,z) = \alpha \cdot P_{parent}(x',y',z') + \beta \cdot noise(x,y,z,seed)
```

где:
- $\alpha$ — коэффициент наследования (0.5-0.9)
- $\beta$ — коэффициент шума (0.1-0.5)
- $(x',y',z')$ — преобразованные координаты родителя

### 2.2 Структура данных

```json
{
  "id": "fractal_stone_001",
  "fractal_depth": 3,
  "base_properties": {
    "color": [0.65, 0.55, 0.45],
    "roughness": 0.8,
    "density": 0.95
  },
  "fractal_rules": [
    {
      "level": 1,
      "subdivision": [2, 2, 2],
      "inheritance": 0.7,
      "noise_factor": 0.2,
      "noise_type": "perlin"
    },
    {
      "level": 2,
      "subdivision": [2, 2, 2],
      "inheritance": 0.8,
      "noise_factor": 0.15,
      "noise_type": "worley"
    },
    {
      "level": 3,
      "subdivision": [2, 2, 2],
      "inheritance": 0.9,
      "noise_factor": 0.05,
      "noise_type": "perlin",
      "detail_mask": "edges_only"
    }
  ],
  "boundary_rules": {
    "continuity": "gradient",
    "neighbor_influence": 0.3
  }
}
```

### 2.3 Реализация шейдера

```glsl
// fractal_cube.glsl
uniform float fractalDepth;
uniform vec3 baseColor;
uniform float noiseScales[4];

float perlinNoise3D(vec3 p) {
  // Стандартная реализация 3D Perlin noise
  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
}

vec3 calculateFractalColor(vec3 pos) {
  vec3 color = baseColor;
  float scale = 1.0;

  for (int level = 0; level < int(fractalDepth); level++) {
    float noise = perlinNoise3D(pos * scale * noiseScales[level]);
    float inheritance = 0.7 + float(level) * 0.05;
    float noiseFactor = 0.2 - float(level) * 0.05;

    color = mix(color, color + vec3(noise - 0.5) * 0.2, noiseFactor);
    scale *= 2.0;
  }

  return clamp(color, 0.0, 1.0);
}

void main() {
  vec3 color = calculateFractalColor(vPosition);
  gl_FragColor = vec4(color, 1.0);
}
```

### 2.4 Сшивка границ для фракталов

**Проблема:** Фрактальный шум по умолчанию не гарантирует непрерывность на границах.

**Решение — граничная интерполяция:**

```glsl
vec3 fractalWithBoundaryBlending(vec3 pos, int cubeIndex) {
  // Определяем расстояние до границы
  vec3 distToEdge = min(pos, 1.0 - pos);
  float minDist = min(distToEdge.x, min(distToEdge.y, distToEdge.z));

  // Внутри куба (далеко от границ)
  if (minDist > 0.1) {
    return calculateFractalColor(pos);
  }

  // Вблизи границы — смешиваем с соседом
  vec3 neighborPos = getNeighborPosition(pos);
  vec3 selfColor = calculateFractalColor(pos);
  vec3 neighborColor = calculateFractalColor(neighborPos);

  float blend = smoothstep(0.0, 0.1, minDist);
  return mix(neighborColor, selfColor, blend);
}
```

### 2.5 Преимущества

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Производительность** | ⭐⭐⭐⭐⭐ | Очень быстрая генерация, O(N) для фиксированной глубины |
| **Компактность данных** | ⭐⭐⭐⭐⭐ | 0.5-2KB на куб (только правила) |
| **Интуитивность** | ⭐⭐⭐⭐ | Легко понять концепцию самоподобия |
| **Процедурная генерация** | ⭐⭐⭐⭐⭐ | Идеально для бесконечных миров |
| **Вариативность** | ⭐⭐⭐⭐ | Множество вариаций из одного набора правил |

### 2.6 Недостатки

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Сшивка границ** | ⭐⭐⭐ | Требует дополнительной обработки |
| **Точный контроль** | ⭐⭐ | Сложно создать конкретный паттерн |
| **Физическая интерпретация** | ⭐⭐ | Нет естественной связи с энергией |
| **ИИ-генерация** | ⭐⭐⭐ | Сложнее обучить модель генерировать правила |
| **Детерминированность** | ⭐⭐⭐ | Зависит от seed, может быть неожиданный результат |

---

## 3. Параметрические функции с градиентами и шумом (Гибридный подход)

### 3.1 Описание метода

Комбинация простых параметрических функций (градиенты по осям, базовые цвета) с процедурным шумом. Этот подход является **золотой серединой** между сложностью FFT и ограничениями фракталов.

#### Математическая формула

```math
C(x,y,z) = BaseColor + \sum_{i} Gradient_i \cdot AxisFactor_i + Noise(x,y,z) \cdot Mask(x,y,z)
```

### 3.2 Структура данных

```json
{
  "id": "stone_moss_001",
  "base": {
    "color": [0.65, 0.55, 0.45],
    "roughness": 0.8,
    "transparency": 1.0
  },
  "gradients": [
    {
      "axis": "y",
      "direction": -1,
      "factor": 0.4,
      "color_shift": [0.2, 0.35, 0.15]
    }
  ],
  "noise": {
    "type": "perlin",
    "scale": 8.0,
    "octaves": 4,
    "persistence": 0.6,
    "mask": "bottom_40%",
    "strength": 0.3
  },
  "physics": {
    "material": "stone",
    "density": 2.5
  }
}
```

### 3.3 Реализация шейдера

```glsl
// parametric_cube.glsl
uniform vec3 baseColor;
uniform vec3 mossGradient;
uniform float noiseScale;

float perlin(vec3 p) {
  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
}

void main() {
  vec3 color = baseColor;

  // Градиент по Y для мха (сильнее внизу)
  float mossFactor = smoothstep(0.6, 0.3, vPosition.y) * 0.7;
  color = mix(color, mossGradient, mossFactor);

  // Добавляем шум для текстуры
  float noise = perlin(vPosition * noiseScale);
  color += (noise - 0.5) * 0.1;

  gl_FragColor = vec4(color, 1.0);
}
```

### 3.4 Сшивка границ

**Метод глобальной параметризации:**

```glsl
vec3 parametricWithGlobalCoords(vec3 localPos, vec3 cubeOffset) {
  vec3 globalPos = localPos + cubeOffset;

  // Градиент использует глобальные координаты
  float mossFactor = smoothstep(0.7, 0.3, fract(globalPos.y * 0.1));

  // Шум также использует глобальные координаты для непрерывности
  float noise = perlin(globalPos * noiseScale);

  return calculateColor(mossFactor, noise);
}
```

### 3.5 Преимущества

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Производительность** | ⭐⭐⭐⭐⭐ | 60 FPS на мобильных без оптимизаций |
| **Контроль над результатом** | ⭐⭐⭐⭐⭐ | Прямое управление параметрами |
| **Понятность для художников** | ⭐⭐⭐⭐⭐ | Интуитивные параметры |
| **Размер данных** | ⭐⭐⭐⭐⭐ | 0.5-2KB на куб |
| **ИИ-генерация** | ⭐⭐⭐⭐⭐ | Легко обучить модель генерировать параметры |

### 3.6 Недостатки

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Сшивка границ** | ⭐⭐⭐⭐ | Хорошая, но не 100% |
| **Сложные паттерны** | ⭐⭐⭐ | Ограничены возможными функциями |
| **Физическая глубина** | ⭐⭐⭐ | Слабая связь с энергетикой |
| **Уникальность** | ⭐⭐⭐ | Похожие кубики при схожих параметрах |

---

## 4. SDF-подход (Signed Distance Functions)

### 4.1 Описание метода

Геометрия кубика определяется через **функцию знакового расстояния** — функцию, возвращающую расстояние от точки до поверхности (отрицательное внутри, положительное снаружи).

#### Математическая основа

```math
SDF_{cube}(p) = |p| - size
```

**Комбинирование SDF:**
- Объединение: $min(SDF_a, SDF_b)$
- Пересечение: $max(SDF_a, SDF_b)$
- Вычитание: $max(SDF_a, -SDF_b)$
- Сглаженное объединение: $smoothMin(SDF_a, SDF_b, k)$

### 4.2 Структура данных

```json
{
  "id": "sdf_crystal_001",
  "primitives": [
    {
      "type": "box",
      "size": [1.0, 1.0, 1.0],
      "transform": {"translate": [0, 0, 0], "rotate": [0, 0, 0]}
    },
    {
      "type": "sphere",
      "radius": 0.3,
      "transform": {"translate": [0.5, 0.5, 0.5]}
    }
  ],
  "operations": [
    {
      "type": "smooth_subtract",
      "a": 0,
      "b": 1,
      "smoothness": 0.1
    }
  ],
  "material": {
    "color_function": "distance_gradient",
    "base_color": [0.8, 0.2, 0.3]
  }
}
```

### 4.3 Реализация шейдера

```glsl
// sdf_cube.glsl
float sdBox(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdSphere(vec3 p, float r) {
  return length(p) - r;
}

float smoothMin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

float sceneSDF(vec3 p) {
  float box = sdBox(p, vec3(0.5));
  float sphere = sdSphere(p - vec3(0.3), 0.2);
  return smoothMin(box, -sphere, 0.1); // Вырез сферой из куба
}

void main() {
  float dist = sceneSDF(vPosition);

  // Цвет зависит от расстояния до поверхности
  vec3 color = mix(vec3(0.8, 0.2, 0.3), vec3(0.2, 0.5, 0.8),
                   smoothstep(-0.1, 0.1, dist));

  float alpha = 1.0 - smoothstep(0.0, 0.05, dist);
  gl_FragColor = vec4(color, alpha);
}
```

### 4.4 Преимущества

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Гибкость форм** | ⭐⭐⭐⭐⭐ | Любые формы через комбинации |
| **Ray marching** | ⭐⭐⭐⭐⭐ | Идеально для объёмного рендеринга |
| **Сглаженные переходы** | ⭐⭐⭐⭐⭐ | Естественные smooth операции |
| **Анимация** | ⭐⭐⭐⭐ | Легко морфить между формами |

### 4.5 Недостатки

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Производительность** | ⭐⭐ | Ray marching дорогой для GPU |
| **Сшивка границ** | ⭐⭐ | Требует специальной обработки |
| **Текстурирование** | ⭐⭐⭐ | Сложнее наложить текстуры |
| **Привычность** | ⭐⭐ | Непривычный подход для художников |

---

## 5. Воксельная декомпозиция с адаптивной детализацией

### 5.1 Описание метода

Куб хранится как **октодерево (octree)** с разной детализацией в разных областях. Детализация увеличивается там, где есть сложные переходы или важные детали.

#### Структура октодерева

```
         Root (1x1x1)
        /    |    \
    Child1  ...  Child8 (0.5x0.5x0.5 каждый)
      |
  Grandchild (0.25x0.25x0.25, если нужна детализация)
```

### 5.2 Структура данных

```json
{
  "id": "octree_terrain_001",
  "max_depth": 4,
  "root": {
    "color": [0.5, 0.4, 0.3],
    "density": 0.8,
    "children": [
      null,
      null,
      {
        "color": [0.3, 0.5, 0.2],
        "density": 0.9,
        "children": null
      },
      {
        "color": [0.6, 0.5, 0.4],
        "density": 0.7,
        "children": [...]
      }
    ]
  },
  "compression": {
    "merge_threshold": 0.05,
    "detail_areas": ["edges", "surface"]
  }
}
```

### 5.3 Преимущества

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Адаптивность** | ⭐⭐⭐⭐⭐ | Детализация где нужно |
| **Эффективность памяти** | ⭐⭐⭐⭐ | Меньше данных для однородных областей |
| **LOD** | ⭐⭐⭐⭐⭐ | Встроенная система уровней детализации |
| **Редактирование** | ⭐⭐⭐⭐ | Легко менять локальные области |

### 5.4 Недостатки

| Критерий | Оценка | Описание |
|----------|--------|----------|
| **Сшивка границ** | ⭐⭐⭐ | Требует согласования уровней между соседями |
| **Сложность реализации** | ⭐⭐⭐ | Рекурсивные структуры сложнее |
| **GPU-рендеринг** | ⭐⭐⭐ | Неравномерная структура плохо ложится на GPU |
| **ИИ-генерация** | ⭐⭐ | Сложно генерировать деревья |

---

## 6. Сравнительная таблица всех подходов

| Критерий | FFT/Спектральный | Фрактальные деревья | Параметрический | SDF | Октодерево |
|----------|------------------|---------------------|-----------------|-----|------------|
| **Сшивка границ** | ⭐⭐⭐⭐⭐ (100%) | ⭐⭐⭐ (80-90%) | ⭐⭐⭐⭐ (90-95%) | ⭐⭐ (70-80%) | ⭐⭐⭐ (85-90%) |
| **Производительность** | ⭐⭐⭐ (30-60 FPS) | ⭐⭐⭐⭐⭐ (60+ FPS) | ⭐⭐⭐⭐⭐ (60+ FPS) | ⭐⭐ (20-40 FPS) | ⭐⭐⭐⭐ (50-60 FPS) |
| **Размер данных** | ⭐⭐⭐⭐ (3-5KB) | ⭐⭐⭐⭐⭐ (0.5-2KB) | ⭐⭐⭐⭐⭐ (0.5-2KB) | ⭐⭐⭐⭐ (1-3KB) | ⭐⭐⭐ (2-10KB) |
| **Физическая модель** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **ИИ-генерация** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **Динамические эффекты** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Простота реализации** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **Контроль результата** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

---

## 7. Рекомендации

### 7.1 Для MVP (минимально жизнеспособный продукт)

**Рекомендуется: Параметрический подход с градиентами и шумом**

**Обоснование:**
- Максимальная производительность из коробки (60 FPS на мобильных)
- Простота реализации и отладки
- Интуитивно понятные параметры для художников
- Лёгкая интеграция с ИИ-генерацией (TinyLLM)
- Достаточная гибкость для большинства типов кубиков

**Архитектура MVP:**
```typescript
interface CubeConfig {
  type: "parametric"; // Расширяемо в будущем
  base: { color: [r, g, b], roughness: number };
  gradients?: Gradient[];
  noise?: NoiseParams;
}
```

### 7.2 Для полной версии

**Рекомендуется: Гибридный подход (Параметрический + FFT)**

**Стратегия:**
1. **Параметрический** — для простых кубиков (камень, дерево, металл)
2. **FFT/Энергетический** — для магических объектов, разрушаемых элементов, сложных взаимодействий

**Архитектура:**
```typescript
interface CubeConfig {
  type: "parametric" | "spectral"; // Выбор подхода

  // Общие поля
  base: BaseProperties;
  physics: PhysicsProperties;

  // Для параметрического
  gradients?: Gradient[];
  noise?: NoiseParams;

  // Для спектрального (FFT)
  spectralCoefficients?: FFTCoefficients;
  energyCapacity?: number;
}
```

### 7.3 Критерии выбора подхода для конкретного кубика

| Тип кубика | Рекомендуемый подход | Обоснование |
|------------|---------------------|-------------|
| Камень, дерево, металл | Параметрический | Простые материалы, высокая производительность |
| Магические кристаллы | FFT/Энергетический | Динамические эффекты, физика энергии |
| Разрушаемые объекты | FFT/Энергетический | Моделирование разрушения через коэффициенты |
| Процедурный ландшафт | Фрактальный | Естественное самоподобие |
| Архитектурные элементы | Параметрический | Чёткий контроль над формой |
| Биомеханические существа | FFT + SDF | Сложные формы с динамикой |

---

## 8. План реализации

### Фаза 1: MVP с параметрическим подходом
1. Реализовать базовый шейдер с градиентами и шумом
2. Создать JSON-схему для конфигов
3. Интегрировать TinyLLM для генерации по промпту
4. Реализовать базовую сшивку границ через глобальные координаты

### Фаза 2: Добавление FFT для магических объектов
1. Реализовать WASM-модуль для FFT
2. Создать шейдер энергетической визуализации
3. Добавить физику энергии (сохранение, передача, разрушение)
4. Интегрировать с системой боя и разрушения

### Фаза 3: Оптимизация и расширение
1. LOD-система для дальних кубиков
2. WebGPU compute-шейдеры
3. Расширение ИИ-модели для сложных промптов
4. Система "стопок кубиков" для вертикальных конструкций

---

## 9. Заключение

Анализ показывает, что **не существует единственного идеального подхода** — каждый метод имеет свои сильные и слабые стороны. Оптимальная стратегия — **гибридная архитектура**, которая позволяет выбирать подход в зависимости от конкретных требований каждого типа кубика.

**Ключевые выводы:**

1. **Параметрический подход** — лучший выбор для MVP и большинства простых кубиков
2. **FFT/Энергетический подход** — идеален для глубокой игровой физики и магических эффектов
3. **Фрактальные деревья** — отлично подходят для процедурной генерации природных текстур
4. **Гибридная архитектура** — позволяет комбинировать преимущества всех подходов

Данный анализ обеспечивает основу для принятия информированного решения о выборе архитектуры системы генерации кубиков в isocubic.
