# Анализ текущей реализации MetaMode и план доработок

## 1. Обзор текущего состояния

MetaMode — унифицированная система метаинформации проекта isocubic, реализованная в рамках Phase 12. Система включает:

- **32 файла `metamode.json`** по всему проекту
- **Спецификацию** (`metamode.md`) с описанием двух форматов: стандартного и компактного
- **2 JSON Schema**: `metamode.schema.json` (стандартная) и `metamode-compact.schema.json` (компактная)
- **Vite-плагин** (`scripts/vite-plugin-metamode.ts`) для компиляции в runtime-артефакты
- **Валидатор** (`scripts/metamode-preprocessor.ts`) для проверки файлов
- **AI-оптимизатор** (`scripts/metamode-ai-optimizer.ts`) для компактного формата
- **Inline-экстрактор** (`scripts/metamode-inline-extractor.ts`) для извлечения метаданных из Vue SFC
- **Runtime-библиотеки**: база данных, LLM-интеграция, store

---

## 2. Выявленные несоответствия

### 2.1 Расхождение между спецификацией и данными

**Проблема**: Спецификация `metamode.md` описывает компактный формат с сокращёнными именами полей (`desc`, `dirs`, `ver`, `lang`, `deps`), но **все 32 файла `metamode.json`** используют старый формат с полными именами (`description`, `directories`, `version`, `languages`, `dependencies`).

| Поле в спецификации | Поле в данных | Статус |
|---------------------|---------------|--------|
| `desc` | `description` | Не мигрировано |
| `dirs` | `directories` | Не мигрировано |
| `ver` | `version` | Не мигрировано |
| `lang` | `languages` | Не мигрировано |
| `deps` | `dependencies` | Не мигрировано |
| `ai` | (отсутствует) | Не добавлено |

**Решение**: Данные файлы валидируются схемой `metamode.schema.json`, которая использует полные имена — это **корректно**. Компактный формат (`metamode-compact.schema.json`) предназначен для **компилированного AI-вывода**, не для хранимых файлов. Однако спецификация `metamode.md` не ясно разграничивает эти два контекста использования.

### 2.2 Отсутствие конвертера metanet → metamode

**Проблема**: В спецификации (раздел 8) упоминается утилита `scripts/metamode-converter.ts` для конвертации metanet.json → metamode.json, но этот файл **не существует** в проекте.

**Решение**: Создать конвертер или удалить упоминание из спецификации.

### 2.3 Дублирование кода между скриптами

**Проблема**: Следующие типы и функции дублируются в нескольких файлах:

- `FileDescriptor`, `MetamodeJson`, `MetamodeTreeNode` — определены в 3 файлах:
  - `scripts/vite-plugin-metamode.ts`
  - `scripts/metamode-preprocessor.ts`
  - `scripts/metamode-ai-optimizer.ts`
- `AIFileDescriptor`, `AIMetamodeTreeNode` — определены в 2 файлах
- `generateAISummary()`, `convertFileToAI()` — дублированы в 2 файлах
- `STATUS_MAP` — определён в 3 файлах
- `loadJson()` — дублирован в 3 файлах
- `compileAIOptimizedTree()` — дублирована полная реализация в 2 файлах

**Решение**: Извлечь общие типы и утилиты в shared-модуль `scripts/metamode-shared.ts`.

### 2.4 Незарегистрированные файлы в metamode.json

**Проблема**: 9 файлов не описаны в соответствующих `metamode.json`:

| Файл | Расположение |
|------|-------------|
| `CLAUDE.md` | корень проекта |
| `metamode-compact.schema.json` | корень проекта |
| `useMetamodeDatabase.ts` | `src/composables/` |
| `metamode-database.test.ts` | `src/lib/` |
| `metamode-database.ts` | `src/lib/` |
| `metamode-inline-extractor.test.ts` | `src/lib/` |
| `metamode-llm-integration.test.ts` | `src/lib/` |
| `metamode-llm-integration.ts` | `src/lib/` |
| `issue-attachments/` | `.github/` |

**Решение**: Добавить описания этих файлов в соответствующие `metamode.json`.

### 2.5 Поле `metamode` в DirectoryDescriptor — избыточно

**Проблема**: Спецификация `metamode.md` (раздел 4.4) указывает, что путь к `metamode.json` подкаталога **автоматически инферируется** как `{dirname}/metamode.json`. Однако:

- Схема `metamode.schema.json` **требует** поле `metamode` (`required: ["description", "metamode"]`)
- Все 32 файла явно указывают `"metamode": "dirname/metamode.json"`
- Компактная схема `metamode-compact.schema.json` **не имеет** этого поля (инферирует)

Это означает, что стандартная схема и спецификация противоречат друг другу.

**Решение**: Поскольку инферирование пути — целевое поведение по спецификации, нужно:
1. Сделать поле `metamode` необязательным в `metamode.schema.json`
2. Обновить валидатор и Vite-плагин для поддержки инферирования
3. Опционально: постепенно удалить явные `metamode` поля из файлов данных

### 2.6 Типы в `src/types/metamode.ts` — для UI, не для метаданных

**Проблема**: Файл `src/types/metamode.ts` содержит типы для **окна MetaMode** (вкладки, позиция окна, shortcuts), а не для формата `metamode.json`. Типы формата определены inline в скриптах. Это создаёт путаницу при навигации по коду.

**Решение**: Хорошо бы разделить типы — отдельно UI-типы и отдельно типы формата данных. Но это рефакторинг, который можно отложить.

---

## 3. Оценка производительности AI-оптимизации

Текущие результаты AI-оптимизатора:

| Метрика | Значение |
|---------|----------|
| Размер оригинала | 42.53 KB |
| Размер AI-оптимизированного | 36.72 KB |
| Экономия | 5.80 KB (13.6%) |
| Всего файлов описано | 333 |
| Всего директорий | 30 |
| Средняя длина описания | 44 символа |

**Наблюдение**: Экономия 13.6% значительно ниже заявленных 30-40% в спецификации. Причина — описания уже достаточно компактны (средняя длина 44 символа), поэтому основная экономия идёт от сокращения имён полей, а не от обрезки текста.

---

## 4. План доработок

### 4.1 Критические (необходимо исправить)

1. **Регистрация недостающих файлов в metamode.json** — 9 файлов не описаны
2. **Уточнение спецификации** — чётко разграничить стандартный и компактный форматы

### 4.2 Важные (рекомендуется)

3. **Извлечение общих типов** — устранить дублирование кода между скриптами
4. **Сделать поле `metamode` опциональным** — привести схему в соответствие со спецификацией
5. **Добавить/удалить конвертер** — либо создать `scripts/metamode-converter.ts`, либо убрать из документации

### 4.3 Желательные (на будущее)

6. **Разделение типов** — UI-типы MetaMode отдельно от типов формата данных
7. **Улучшение AI-оптимизации** — довести экономию до заявленных 30%+
8. **Поддержка двустороннего формата** — чтобы инструменты работали как со стандартным, так и с компактным форматом
